// Generated by CoffeeScript 1.10.0
(function() {
  var initHeterarchy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  initHeterarchy = function(exports) {
    var assert, copyOwn, every, find, generate, head, hierarchy, inherited, isEmpty, isEqual, isJavaScriptClass, map, memoize, merge, mro, partial, reject, reparent, some, tail, without;
    head = _.head, tail = _.tail, map = _.map, find = _.find, some = _.some, without = _.without, isEmpty = _.isEmpty, every = _.every, memoize = _.memoize, reject = _.reject, partial = _.partial, isEqual = _.isEqual;
    assert = function(value, error) {
      if (!value) {
        throw new Error(error != null ? error : "Assertion failed");
      }
    };
    generate = memoize(function(linearization) {
      var Result, next;
      next = head(linearization);
      if (isEqual(linearization, hierarchy(next))) {
        return next;
      } else {
        return Result = (function(superClass) {
          var class1, key, value;

          extend(Result, superClass);

          function Result() {
            return class1.apply(this, arguments);
          }

          Result.prototype.__mro__ = linearization;

          class1 = reparent(next, Result, next.prototype.constructor);

          copyOwn(next, Result);

          for (key in next) {
            if (!hasProp.call(next, key)) continue;
            value = next[key];
            if (value instanceof Function) {
              Result[key] = partial(reparent, next, Result)(value);
            }
          }

          copyOwn(next.prototype, Result.prototype, partial(reparent, next, Result));

          return Result;

        })(generate(tail(linearization)));
      }
    });
    copyOwn = function(from, to, project) {
      var key, value;
      if (project == null) {
        project = function(x) {
          return x;
        };
      }
      for (key in from) {
        if (!hasProp.call(from, key)) continue;
        value = from[key];
        if (!to.hasOwnProperty(key)) {
          to[key] = project(value);
        }
      }
      return to;
    };
    reparent = function(oldklass, newklass, value) {
      var newParent, newsuper, oldsuper, superctor;
      if (!(value instanceof Function)) {
        newParent = value;
      } else if (value === oldklass.prototype.constructor && inherited(oldklass) === Object) {
        superctor = inherited(newklass).prototype.constructor;
        newParent = function() {
          superctor.apply(this, arguments);
          return value.apply(this, arguments);
        };
      } else {
        newsuper = inherited(newklass).prototype;
        oldsuper = oldklass.__super__;
        newParent = function() {
          oldklass.__super__ = newsuper;
          try {
            return value.apply(this, arguments);
          } finally {
            oldklass.__super__ = oldsuper;
          }
        };
      }
      return newParent;
    };
    merge = function(inputs) {
      var next, results;
      results = [];
      while (!isEmpty(inputs)) {
        next = find(map(inputs, head), function(candidate) {
          return every(inputs, function(input) {
            return indexOf.call(tail(input), candidate) < 0;
          });
        });
        assert(next != null, "Inconsistent multiple inheritance");
        inputs = reject(map(inputs, function(lst) {
          return without(lst, next);
        }), isEmpty);
        results.push(next);
      }
      return results;
    };
    isJavaScriptClass = function(cls) {
      return cls === Array || cls === Boolean || cls === Date || cls === Error || cls === Function || cls === Number || cls === RegExp || cls === String || cls === Object;
    };
    exports.multi = function() {
      var bases;
      bases = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return generate(merge(map(bases, mro).concat([bases])));
    };
    exports.mro = mro = function(cls) {
      var result;
      if ((cls == null) || (cls.prototype == null)) {
        return [];
      } else if (!cls.prototype.hasOwnProperty('__mro__')) {
        result = [cls].concat(mro(inherited(cls)));
        if (!isJavaScriptClass(cls)) {
          cls.prototype.__mro__ = result;
        }
        return result;
      } else {
        return cls.prototype.__mro__;
      }
    };
    exports.inherited = inherited = function(cls) {
      var ref;
      return (ref = Object.getPrototypeOf(cls.prototype)) != null ? ref.constructor : void 0;
    };
    exports.hierarchy = hierarchy = function(cls) {
      if (cls == null) {
        return [];
      } else {
        return [cls].concat(hierarchy(inherited(cls)));
      }
    };
    exports.isinstance = function() {
      var classes, obj;
      obj = arguments[0], classes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return exports.issubclass.apply(exports, [obj != null ? obj.constructor : void 0].concat(slice.call(classes)));
    };
    return exports.issubclass = function() {
      var classes, klass, linearization;
      klass = arguments[0], classes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      linearization = mro(klass);
      return some(classes, function(cls) {
        return indexOf.call(linearization, cls) >= 0;
      });
    };
  };

  window.heterarchy = {};

  initHeterarchy(window.heterarchy);

}).call(this);
